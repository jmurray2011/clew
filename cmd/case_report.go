package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"sort"
	"strings"
	"time"

	"github.com/jmurray2011/clew/internal/cases"
)

// generateMarkdownReport creates a Markdown report for the case.
func generateMarkdownReport(c *cases.Case, full bool) (string, error) {
	var b strings.Builder

	// Header
	b.WriteString(fmt.Sprintf("# %s\n\n", c.Title))
	b.WriteString(fmt.Sprintf("**Case ID:** %s\n\n", c.ID))
	b.WriteString(fmt.Sprintf("**Status:** %s\n\n", c.Status))
	b.WriteString(fmt.Sprintf("**Created:** %s\n\n", c.Created.Format("2006-01-02 15:04:05")))
	b.WriteString(fmt.Sprintf("**Updated:** %s\n\n", c.Updated.Format("2006-01-02 15:04:05")))
	b.WriteString(fmt.Sprintf("**Generated:** %s\n\n", time.Now().Format("2006-01-02 15:04:05")))

	// Summary
	if c.Summary != "" {
		b.WriteString("## Summary\n\n")
		b.WriteString(c.Summary)
		b.WriteString("\n\n")
	}

	// Key Evidence
	if len(c.Evidence) > 0 {
		b.WriteString("## Key Evidence\n\n")
		for i, e := range c.Evidence {
			b.WriteString(fmt.Sprintf("### Evidence %d\n\n", i+1))
			if !e.Timestamp.IsZero() {
				b.WriteString(fmt.Sprintf("**Timestamp:** %s\n\n", e.Timestamp.Format("2006-01-02 15:04:05")))
			}
			// Prefer new fields, fall back to deprecated
			source := e.SourceURI
			if source == "" {
				source = e.LogGroup
			}
			b.WriteString(fmt.Sprintf("**Source:** %s\n\n", source))
			stream := e.Stream
			if stream == "" {
				stream = e.LogStream
			}
			if stream != "" {
				b.WriteString(fmt.Sprintf("**Stream:** %s\n\n", stream))
			}
			if e.Annotation != "" {
				b.WriteString(fmt.Sprintf("**Annotation:** %s\n\n", e.Annotation))
			}
			b.WriteString("**Log Message:**\n```\n")
			b.WriteString(e.Message)
			b.WriteString("\n```\n\n")

			// Include additional fields from raw log record if available
			if len(e.RawFields) > 0 {
				// Show key fields that aren't already displayed
				var extraFields []string
				for k, v := range e.RawFields {
					// Skip fields already shown
					if k == "@message" || k == "@timestamp" || k == "@logStream" || k == "@logGroup" || k == "@ptr" {
						continue
					}
					if v != "" {
						extraFields = append(extraFields, fmt.Sprintf("- **%s:** `%s`", k, v))
					}
				}
				if len(extraFields) > 0 {
					sort.Strings(extraFields)
					b.WriteString("**Additional Fields:**\n\n")
					for _, f := range extraFields {
						b.WriteString(f + "\n")
					}
					b.WriteString("\n")
				}
			}
		}
	}

	// Investigation Timeline
	b.WriteString("## Investigation Timeline\n\n")

	// Filter timeline entries
	var entries []cases.TimelineEntry
	for _, e := range c.Timeline {
		if full || e.Marked || e.Type == "note" || e.Type == "evidence" {
			entries = append(entries, e)
		}
	}

	if len(entries) == 0 {
		b.WriteString("_No timeline entries._\n\n")
	} else {
		for _, e := range entries {
			ts := e.Timestamp.Format("2006-01-02 15:04:05")
			switch e.Type {
			case "query":
				marker := ""
				if e.Marked {
					marker = " [*]"
				}
				b.WriteString(fmt.Sprintf("### %s - Query%s\n\n", ts, marker))
				if e.Command != "" {
					b.WriteString(fmt.Sprintf("```\n%s\n```\n\n", e.Command))
				}
				// Prefer new fields, fall back to deprecated
				sourceDisplay := e.SourceURI
				if sourceDisplay == "" {
					sourceDisplay = e.LogGroup
				}
				if sourceDisplay != "" {
					b.WriteString(fmt.Sprintf("**Source:** %s\n\n", sourceDisplay))
				}
				if e.Filter != "" {
					b.WriteString(fmt.Sprintf("**Filter:** `%s`\n\n", e.Filter))
				}
				if e.Query != "" {
					b.WriteString(fmt.Sprintf("**Query:**\n```\n%s\n```\n\n", e.Query))
				}
				b.WriteString(fmt.Sprintf("**Results:** %d\n\n", e.Results))

			case "note":
				b.WriteString(fmt.Sprintf("### %s - Note\n\n", ts))
				b.WriteString(e.Content)
				b.WriteString("\n\n")

			case "evidence":
				b.WriteString(fmt.Sprintf("### %s - Evidence Collected\n\n", ts))
				if e.Source != "" {
					b.WriteString(fmt.Sprintf("**Source:** %s\n\n", e.Source))
				}
				if e.Content != "" {
					content := e.Content
					if len(content) > 200 {
						content = content[:197] + "..."
					}
					b.WriteString(fmt.Sprintf("```\n%s\n```\n\n", content))
				}
			}
		}
	}

	// Footer
	b.WriteString("---\n\n")
	b.WriteString("_Generated by clew_\n")

	return b.String(), nil
}

// generateJSONReport creates a JSON report for the case.
func generateJSONReport(c *cases.Case, full bool) (string, error) {
	type reportData struct {
		ID        string                `json:"id"`
		Title     string                `json:"title"`
		Status    string                `json:"status"`
		Created   time.Time             `json:"created"`
		Updated   time.Time             `json:"updated"`
		Generated time.Time             `json:"generated"`
		Summary   string                `json:"summary,omitempty"`
		Evidence  []cases.EvidenceItem  `json:"evidence,omitempty"`
		Timeline  []cases.TimelineEntry `json:"timeline,omitempty"`
	}

	// Filter timeline if not full
	var timeline []cases.TimelineEntry
	if full {
		timeline = c.Timeline
	} else {
		for _, e := range c.Timeline {
			if e.Marked || e.Type == "note" || e.Type == "evidence" {
				timeline = append(timeline, e)
			}
		}
	}

	data := reportData{
		ID:        c.ID,
		Title:     c.Title,
		Status:    string(c.Status),
		Created:   c.Created,
		Updated:   c.Updated,
		Generated: time.Now(),
		Summary:   c.Summary,
		Evidence:  c.Evidence,
		Timeline:  timeline,
	}

	jsonBytes, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to generate JSON: %w", err)
	}

	return string(jsonBytes) + "\n", nil
}

// generatePDFReport creates a PDF report using Typst.
func generatePDFReport(c *cases.Case, full bool, outputPath string) error {
	// Check if typst is installed
	if _, err := exec.LookPath("typst"); err != nil {
		return fmt.Errorf("typst not found. Install from https://typst.app or use --format md")
	}

	// Generate Typst source
	typstContent := generateTypstReport(c, full)

	// Create temp file for Typst source
	tmpfile, err := os.CreateTemp("", "clew-report-*.typ")
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}
	defer func() { _ = os.Remove(tmpfile.Name()) }()

	if _, err := tmpfile.WriteString(typstContent); err != nil {
		return fmt.Errorf("failed to write typst file: %w", err)
	}
	_ = tmpfile.Close()

	// Determine output path
	if outputPath == "" {
		outputPath = c.ID + ".pdf"
	}

	// Run typst compile
	typstCmd := exec.Command("typst", "compile", tmpfile.Name(), outputPath)
	typstCmd.Stderr = os.Stderr

	if err := typstCmd.Run(); err != nil {
		return fmt.Errorf("typst compilation failed: %w", err)
	}

	// Note: render.Success is handled by the caller (runCaseReport)
	return nil
}

// generateTypstReport creates a Typst source document for PDF generation.
func generateTypstReport(c *cases.Case, full bool) string {
	var b strings.Builder

	// Document setup with proper code block handling for long stack traces
	b.WriteString(`#set document(title: "` + escapeTypst(c.Title) + `")
#set page(margin: 1in)
#set text(size: 11pt)
#set heading(numbering: "1.")

// Make code blocks breakable across pages and use smaller font
#show raw.where(block: true): it => block(
  width: 100%,
  fill: luma(245),
  inset: 8pt,
  radius: 4pt,
  breakable: true,
  text(size: 8pt, it)
)

// Wrap long lines in code blocks
#set raw(theme: none)

`)

	// Title
	b.WriteString(fmt.Sprintf("= %s\n\n", escapeTypst(c.Title)))

	// Metadata table
	b.WriteString(`#table(
  columns: (auto, 1fr),
  stroke: none,
  [*Case ID:*], [` + escapeTypst(c.ID) + `],
  [*Status:*], [` + escapeTypst(string(c.Status)) + `],
  [*Created:*], [` + c.Created.Format("2006-01-02 15:04:05") + `],
  [*Updated:*], [` + c.Updated.Format("2006-01-02 15:04:05") + `],
  [*Generated:*], [` + time.Now().Format("2006-01-02 15:04:05") + `],
)

`)

	// Summary
	if c.Summary != "" {
		b.WriteString("== Summary\n\n")
		b.WriteString(escapeTypst(c.Summary))
		b.WriteString("\n\n")
	}

	// Key Evidence
	if len(c.Evidence) > 0 {
		b.WriteString("== Key Evidence\n\n")
		for i, e := range c.Evidence {
			b.WriteString(fmt.Sprintf("=== Evidence %d\n\n", i+1))
			if !e.Timestamp.IsZero() {
				b.WriteString(fmt.Sprintf("*Timestamp:* %s\n\n", e.Timestamp.Format("2006-01-02 15:04:05")))
			}
			// Prefer new fields, fall back to deprecated
			source := e.SourceURI
			if source == "" {
				source = e.LogGroup
			}
			b.WriteString(fmt.Sprintf("*Source:* %s\n\n", escapeTypst(source)))
			stream := e.Stream
			if stream == "" {
				stream = e.LogStream
			}
			if stream != "" {
				b.WriteString(fmt.Sprintf("*Stream:* %s\n\n", escapeTypst(stream)))
			}
			if e.Annotation != "" {
				b.WriteString(fmt.Sprintf("*Annotation:* %s\n\n", escapeTypst(e.Annotation)))
			}
			b.WriteString("*Log Message:*\n```\n")
			b.WriteString(wrapLongLines(e.Message, 85))
			b.WriteString("\n```\n\n")

			// Include additional fields from raw log record if available
			if len(e.RawFields) > 0 {
				var extraFields []string
				for k, v := range e.RawFields {
					if k == "@message" || k == "@timestamp" || k == "@logStream" || k == "@logGroup" || k == "@ptr" {
						continue
					}
					if v != "" {
						extraFields = append(extraFields, fmt.Sprintf("- *%s:* `%s`", escapeTypst(k), escapeTypst(v)))
					}
				}
				if len(extraFields) > 0 {
					sort.Strings(extraFields)
					b.WriteString("*Additional Fields:*\n\n")
					for _, f := range extraFields {
						b.WriteString(f + "\n")
					}
					b.WriteString("\n")
				}
			}
		}
	}

	// Investigation Timeline
	b.WriteString("== Investigation Timeline\n\n")

	// Filter timeline entries
	var entries []cases.TimelineEntry
	for _, e := range c.Timeline {
		if full || e.Marked || e.Type == "note" || e.Type == "evidence" {
			entries = append(entries, e)
		}
	}

	if len(entries) == 0 {
		b.WriteString("_No timeline entries._\n\n")
	} else {
		for _, e := range entries {
			ts := e.Timestamp.Format("2006-01-02 15:04:05")
			switch e.Type {
			case "query":
				marker := ""
				if e.Marked {
					marker = " (marked)"
				}
				b.WriteString(fmt.Sprintf("=== %s - Query%s\n\n", ts, marker))
				if e.Command != "" {
					b.WriteString(fmt.Sprintf("```\n%s\n```\n\n", wrapLongLines(e.Command, 85)))
				}
				// Prefer new fields, fall back to deprecated
				sourceDisplay := e.SourceURI
				if sourceDisplay == "" {
					sourceDisplay = e.LogGroup
				}
				if sourceDisplay != "" {
					b.WriteString(fmt.Sprintf("*Source:* %s\n\n", escapeTypst(sourceDisplay)))
				}
				if e.Filter != "" {
					b.WriteString(fmt.Sprintf("*Filter:* `%s`\n\n", escapeTypst(e.Filter)))
				}
				if e.Query != "" {
					b.WriteString(fmt.Sprintf("*Query:*\n```\n%s\n```\n\n", wrapLongLines(e.Query, 85)))
				}
				b.WriteString(fmt.Sprintf("*Results:* %d\n\n", e.Results))

			case "note":
				b.WriteString(fmt.Sprintf("=== %s - Note\n\n", ts))
				b.WriteString(escapeTypst(e.Content))
				b.WriteString("\n\n")

			case "evidence":
				b.WriteString(fmt.Sprintf("=== %s - Evidence Collected\n\n", ts))
				if e.Source != "" {
					b.WriteString(fmt.Sprintf("*Source:* %s\n\n", escapeTypst(e.Source)))
				}
				if e.Content != "" {
					content := e.Content
					if len(content) > 200 {
						content = content[:197] + "..."
					}
					b.WriteString(fmt.Sprintf("```\n%s\n```\n\n", wrapLongLines(content, 85)))
				}
			}
		}
	}

	// Footer
	b.WriteString("#line(length: 100%)\n")
	b.WriteString("#text(size: 9pt, fill: gray)[_Generated by clew_]\n")

	return b.String()
}

// escapeTypst escapes special characters for Typst.
func escapeTypst(s string) string {
	// Escape characters that have special meaning in Typst
	replacer := strings.NewReplacer(
		"#", "\\#",
		"$", "\\$",
		"@", "\\@",
		"*", "\\*",
		"_", "\\_",
		"[", "\\[",
		"]", "\\]",
		"<", "\\<",
		">", "\\>",
	)
	return replacer.Replace(s)
}

// wrapLongLines wraps lines longer than maxWidth characters for better PDF rendering.
func wrapLongLines(s string, maxWidth int) string {
	var result strings.Builder
	lines := strings.Split(s, "\n")
	for i, line := range lines {
		if i > 0 {
			result.WriteString("\n")
		}
		if len(line) <= maxWidth {
			result.WriteString(line)
		} else {
			// Wrap long line
			for len(line) > maxWidth {
				// Try to break at a reasonable point (space, tab, or after certain chars)
				breakPoint := maxWidth
				for bp := maxWidth; bp > maxWidth-20 && bp > 0; bp-- {
					if line[bp] == ' ' || line[bp] == '\t' || line[bp] == '.' || line[bp] == ',' || line[bp] == '(' || line[bp] == ')' {
						breakPoint = bp + 1
						break
					}
				}
				result.WriteString(line[:breakPoint])
				result.WriteString("\n")
				line = "    " + line[breakPoint:] // indent continuation
			}
			result.WriteString(line)
		}
	}
	return result.String()
}
